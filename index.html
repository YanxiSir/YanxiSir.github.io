<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Yanxi&apos;s zone">
<meta property="og:type" content="website">
<meta property="og:title" content="YanxiSir">
<meta property="og:url" content="http://yanxisir.com/index.html">
<meta property="og:site_name" content="YanxiSir">
<meta property="og:description" content="Yanxi&apos;s zone">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="YanxiSir">
<meta name="twitter:description" content="Yanxi&apos;s zone">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yanxisir.com/"/>





  <title>YanxiSir</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YanxiSir</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">心中田间,木行水上</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yanxisir.com/2018/07/09/面试题解答/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yanxi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YanxiSir">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/09/面试题解答/" itemprop="url">面试题解答</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-09T19:44:23+08:00">
                2018-07-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="基本功"><a href="#基本功" class="headerlink" title="基本功"></a>基本功</h3><h4 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h4><p><a href="https://blog.csdn.net/qq_15150353/article/details/52649349" target="_blank" rel="noopener">传送门</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">三大特征：封装、继承、多态</span><br><span class="line">五大原则：单一职责原则、替换原则、开放封闭原则(更改性封闭，扩展性开放)、依赖倒置原则(依赖抽象不能依赖具体，对抽象编程不能对实现进行编程)、接口隔离原则</span><br></pre></td></tr></table></figure>
<h4 id="final-finally-finalize-的区别"><a href="#final-finally-finalize-的区别" class="headerlink" title="final, finally, finalize 的区别"></a>final, finally, finalize 的区别</h4><p><a href="http://www.iteye.com/topic/484934" target="_blank" rel="noopener">深入理解finalize</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Final：用于修饰类、成员变量和成员方法。final修饰的类不能被继承(String、StringBuilder、StringBuffer、Math、不可变类)，其中所有的方法都不能被重写，所以不能同时用abstract和final修饰类。final修饰的方法不能被重写，但是子类可以用父类中final修饰的方法。final修饰的成员变量是不可变的，基本数据类型值不可变，引用类型，指向的对象不遍，对象内容可变。</span><br><span class="line">Finally：通常和try catch搭配使用，保证不管有没有异常发生，资源都能够被释放(释放连接、关闭IO流)。</span><br><span class="line">Finalize：是Object类中的一个方法，子类可以重写finalize()方法实现对资源的回收。辣鸡回收只负责回收内存，并不负责资源的回收，资源回收要由程序员完成，JVM在垃圾回收之前会先调用垃圾对象的finalize方式用于使对象释放资源(如关闭连接、关闭文件)，之后才进行垃圾回收，这个方法一般不会显示的调用，在垃圾回收时垃圾回收器会主动调用。</span><br></pre></td></tr></table></figure>
<h4 id="int-和-Integer-有什么区别"><a href="#int-和-Integer-有什么区别" class="headerlink" title="int 和 Integer 有什么区别"></a>int 和 Integer 有什么区别</h4><p><a href="https://blog.csdn.net/login_sonata/article/details/71001851" target="_blank" rel="noopener">int &amp; Integer对比</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Ingeter是<span class="keyword">int</span>的包装类，<span class="keyword">int</span>的初值为<span class="number">0</span>，Ingeter的初值为<span class="keyword">null</span>。除此之外还有区别，请看代码：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInteger</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">128</span>;  </span><br><span class="line">        Integer i2 = <span class="number">128</span>;  </span><br><span class="line">        Integer i3 = <span class="keyword">new</span> Integer(<span class="number">128</span>);  </span><br><span class="line">        System.out.println(i == i2); <span class="comment">//Integer会自动拆箱为int，所以为true  </span></span><br><span class="line">        System.out.println(i == i3); <span class="comment">//true，理由同上  </span></span><br><span class="line">        Integer i4 = <span class="number">127</span>;<span class="comment">//编译时被翻译成：Integer i4 = Integer.valueOf(127);  </span></span><br><span class="line">        Integer i5 = <span class="number">127</span>;  </span><br><span class="line">        System.out.println(i4 == i5);<span class="comment">//true  </span></span><br><span class="line">        Integer i6 = <span class="number">128</span>;  </span><br><span class="line">        Integer i7 = <span class="number">128</span>;  </span><br><span class="line">        System.out.println(i6 == i7);<span class="comment">//false  </span></span><br><span class="line">        Integer i8 = <span class="keyword">new</span> Integer(<span class="number">127</span>);  </span><br><span class="line">        System.out.println(i5 == i8); <span class="comment">//false  </span></span><br><span class="line">        Integer i9 = <span class="keyword">new</span> Integer(<span class="number">128</span>);  </span><br><span class="line">        Integer i10 = <span class="keyword">new</span> Integer(<span class="number">123</span>);  </span><br><span class="line">        System.out.println(i9 == i10);  <span class="comment">//false  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">为什么i4和i5比是<span class="keyword">true</span>，而i6和i7比是<span class="keyword">false</span>呢？关键就是看valueOf()函数了，这个函数对于-<span class="number">128</span>到<span class="number">127</span>之间的数，会进行缓存， Integer i5 = <span class="number">127</span>时，会将<span class="number">127</span>进行缓存，下次再写Integer i6 = <span class="number">127</span>时，就会直接从缓存中取，就不会<span class="keyword">new</span>了。所以i4和i5比是<span class="keyword">true</span>，而i6和i7比是<span class="keyword">false</span>。</span><br><span class="line"></span><br><span class="line">而对于后边的i5和i8，以及i9和i10，因为对象不一样，所以为<span class="keyword">false</span>。</span><br><span class="line"></span><br><span class="line">以上的情况总结如下：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>，无论如何，Integer与<span class="keyword">new</span> Integer不会相等。不会经历拆箱过程，<span class="keyword">new</span>出来的对象存放在堆，而非<span class="keyword">new</span>的Integer常量则在常量池（在方法区），他们的内存地址不一样，所以为<span class="keyword">false</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>，两个都是非<span class="keyword">new</span>出来的Integer，如果数在-<span class="number">128</span>到<span class="number">127</span>之间，则是<span class="keyword">true</span>,否则为<span class="keyword">false</span>。因为java在编译Integer i2 = <span class="number">128</span>的时候,被翻译成：Integer i2 = Integer.valueOf(<span class="number">128</span>);而valueOf()函数会对-<span class="number">128</span>到<span class="number">127</span>之间的数进行缓存。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>，两个都是<span class="keyword">new</span>出来的,都为<span class="keyword">false</span>。还是内存地址不一样。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>，<span class="keyword">int</span>和Integer(无论<span class="keyword">new</span>否)比，都为<span class="keyword">true</span>，因为会把Integer自动拆箱为<span class="keyword">int</span>再去比。</span><br></pre></td></tr></table></figure>
<h4 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法重写(overriding)：1、也叫子类方法覆盖父类方法，要求返回值、方法名和参数相同；2、子类异常不能超出父类异常；3、子类访问级别不能低于父类访问级别</span><br><span class="line">方法重载(overloading)：重载是在同一个类中存在两个或两个以上的同名方法，但是参数不相同，方法体也不相同。最常用的重载例子便是构造函数。</span><br></pre></td></tr></table></figure>
<h4 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h4><p><a href="https://www.cnblogs.com/zhang-can/p/7215506.html" target="_blank" rel="noopener">进程&amp;线程&amp;协程那些事儿</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">进程、线程和协程之间的关系和区别也困扰我一阵子了，最近有一些心得，写一下。</span><br><span class="line"></span><br><span class="line">进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。</span><br><span class="line"></span><br><span class="line">线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。</span><br><span class="line"></span><br><span class="line">协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。</span><br><span class="line"></span><br><span class="line">进程和其他两个的区别还是很明显的。</span><br><span class="line"></span><br><span class="line">协程和线程的区别是：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。</span><br><span class="line"></span><br><span class="line">打个比方吧，假设有一个操作系统，是单核的，系统上没有其他的程序需要运行，有两个线程 A 和 B ，A 和 B 在单独运行时都需要 10 秒来完成自己的任务，而且任务都是运算操作，A B 之间也没有竞争和共享数据的问题。现在 A B 两个线程并行，操作系统会不停的在 A B 两个线程之间切换，达到一种伪并行的效果，假设切换的频率是每秒一次，切换的成本是 0.1 秒(主要是栈切换)，总共需要 20 + 19 * 0.1 = 21.9 秒。如果使用协程的方式，可以先运行协程 A ，A 结束的时候让位给协程 B ，只发生一次切换，总时间是 20 + 1 * 0.1 = 20.1 秒。如果系统是双核的，而且线程是标准线程，那么 A B 两个线程就可以真并行，总时间只需要 10 秒，而协程的方案仍然需要 20.1 秒。</span><br></pre></td></tr></table></figure>
<h5 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">进程间通信方式：队列和管道</span><br><span class="line">线程间通信方式：</span><br><span class="line">	-| 同步：synchronized 这种方式，本质上就是“共享内存”式的通信。多个线程需要访问同一个共享变量，谁拿到了锁（获得了访问权限），谁就可以执行。</span><br><span class="line">	-| while轮询： </span><br><span class="line">	-| wait/notify机制</span><br><span class="line">	-| 管道通信</span><br><span class="line">分布式系统中说的两种通信机制：共享内存机制和消息通信机制。</span><br></pre></td></tr></table></figure>
<h4 id="抽象类和接口有什么区别"><a href="#抽象类和接口有什么区别" class="headerlink" title="抽象类和接口有什么区别"></a>抽象类和接口有什么区别</h4><p><a href="http://www.importnew.com/12399.html" target="_blank" rel="noopener">Java抽象类和接口的区别</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">抽象类：用来捕捉子类的通用特性，不能被实例化，只能被用作子类的超类。</span><br><span class="line">接口：抽象方法的集合。</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>抽象类</strong></th>
<th><strong>接口</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>默认的方法实现</td>
<td>它可以有默认的方法实现</td>
<td>接口完全是抽象的。它根本不存在方法的实现</td>
</tr>
<tr>
<td>实现</td>
<td>子类使用<strong>extends</strong>关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td>
<td>子类使用关键字<strong>implements</strong>来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类可以有构造器</td>
<td>接口不能有构造器</td>
</tr>
<tr>
<td>与正常Java类的区别</td>
<td>除了你不能实例化抽象类之外，它和普通Java类没有任何区别</td>
<td>接口是完全不同的类型</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象方法可以有<strong>public</strong>、<strong>protected</strong>和<strong>default</strong>这些修饰符</td>
<td>接口方法默认修饰符是<strong>public</strong>。你不可以使用其它修饰符。</td>
</tr>
<tr>
<td>main方法</td>
<td>抽象方法可以有main方法并且我们可以运行它</td>
<td>接口没有main方法，因此我们不能运行它。</td>
</tr>
<tr>
<td>多继承</td>
<td>抽象方法可以继承一个类和实现多个接口</td>
<td>接口只可以继承一个或多个其它接口</td>
</tr>
<tr>
<td>速度</td>
<td>它比接口速度要快</td>
<td>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</td>
</tr>
<tr>
<td>添加新方法</td>
<td>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。</td>
<td>如果你往接口中添加方法，那么你必须改变实现该接口的类。</td>
</tr>
</tbody>
</table>
<h4 id="说说反射的用途及实现"><a href="#说说反射的用途及实现" class="headerlink" title="说说反射的用途及实现"></a>说说反射的用途及实现</h4><p><a href="https://www.sczyh30.com/posts/Java/java-reflection-1/" target="_blank" rel="noopener">深入解析Java反射</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">反射(Reflection)是Java程序开发语言的特征之一，它允许运行中的Java程序获取自身的信息，并且可以操作类或对象的内部属性。</span><br><span class="line"></span><br><span class="line">Java反射框架主要功能：</span><br><span class="line">1、在运行时判断任意一个对象所属类；</span><br><span class="line">2、在运行时构造任意一个类的对象；</span><br><span class="line">3、在运行时判断任意一个类所具有的成员变量和方法(通过反射甚至可以调用private方法);</span><br><span class="line">4、在运行时调用任意一个对象的方法</span><br><span class="line">** 运行时，不是编译时</span><br><span class="line"></span><br><span class="line">** 注意事项</span><br><span class="line">1、反射会消耗一定的系统资源，因此如果不需要动态的创建一个对象，那么就不需要用反射</span><br><span class="line">2、反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</span><br></pre></td></tr></table></figure>
<h4 id="说说自定义注解的场景及实现"><a href="#说说自定义注解的场景及实现" class="headerlink" title="说说自定义注解的场景及实现"></a>说说自定义注解的场景及实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主要看自己理解，是否在项目中用过。(登录、权限拦截、日志处理 etc...)</span><br></pre></td></tr></table></figure>
<h4 id="HTTP-请求的-GET-与-POST-方式的区别"><a href="#HTTP-请求的-GET-与-POST-方式的区别" class="headerlink" title="HTTP 请求的 GET 与 POST 方式的区别"></a>HTTP 请求的 GET 与 POST 方式的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET的优点: </span><br><span class="line">1.执行效率比POST高。 </span><br><span class="line">2.可以通过url传递数据，查找数据的时候就会体现到它的好处。 </span><br><span class="line">GET的缺点: </span><br><span class="line">1.安全性很低，因为上传的数据都会显示在url上，所以一般用在上传无关紧要的数据上。 </span><br><span class="line">2.上传的数据量较小，一般不能超过4K.这也是因为url的长度而被限制的。</span><br><span class="line"></span><br><span class="line">POST优点: </span><br><span class="line">1.安全性高，但是也不是很高，如果想要高安全性的话就用https传输协议。 </span><br><span class="line">2.上传的数据量比GET大得多。“理论上讲，POST是没有大小限制的，HTTP协议规范也没有进行大小限制，说“POST数据量存在 80K/100K的大小限制”是不准确的，POST数据是没有限制的，起限制作用的是服务器的处理程序的处理能力。”</span><br><span class="line">POST缺点: </span><br><span class="line">1.执行效率比GET低，但是现在的计算机都很强大，这些几乎可以忽略不计，所以建议一般都使用POST方式。 </span><br><span class="line">2.不可以通过url传递数据，有时候可能会不方便.</span><br></pre></td></tr></table></figure>
<h4 id="session-与-cookie-区别"><a href="#session-与-cookie-区别" class="headerlink" title="session 与 cookie 区别"></a>session 与 cookie 区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cookie 和session 的区别：</span><br><span class="line"></span><br><span class="line">1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</span><br><span class="line">2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗</span><br><span class="line">   考虑到安全应当使用session。</span><br><span class="line">3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能</span><br><span class="line">   考虑到减轻服务器性能方面，应当使用COOKIE。</span><br><span class="line">4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</span><br><span class="line">5、所以个人建议：</span><br><span class="line">   将登陆信息等重要信息存放为SESSION</span><br><span class="line">   其他信息如果需要保留，可以放在COOKIE中</span><br></pre></td></tr></table></figure>
<h4 id="什么是跨域-怎么解决跨域问题"><a href="#什么是跨域-怎么解决跨域问题" class="headerlink" title="什么是跨域/怎么解决跨域问题"></a>什么是跨域/怎么解决跨域问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器施加的安全限制。</span><br><span class="line">所谓同源是指，域名，协议，端口均相同，不明白没关系，举个栗子：</span><br><span class="line">http://www.123.com/index.html 调用 http://www.123.com/server.php （非跨域）</span><br><span class="line">http://www.123.com/index.html 调用 http://www.456.com/server.php （主域名不同:123/456，跨域）</span><br><span class="line">http://abc.123.com/index.html 调用 http://def.123.com/server.php （子域名不同:abc/def，跨域）</span><br><span class="line">http://www.123.com:8080/index.html 调用 http://www.123.com:8081/server.php （端口不同:8080/8081，跨域）</span><br><span class="line">http://www.123.com/index.html 调用 https://www.123.com/server.php （协议不同:http/https，跨域）</span><br><span class="line">请注意：localhost和127.0.0.1虽然都指向本机，但也属于跨域。</span><br><span class="line">浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行。</span><br><span class="line"></span><br><span class="line">解决办法：</span><br><span class="line"></span><br><span class="line">1、JSONP：</span><br><span class="line">使用方式就不赘述了，但是要注意JSONP只支持GET请求，不支持POST请求。</span><br><span class="line"></span><br><span class="line">2、代理：</span><br><span class="line">例如www.123.com/index.html需要调用www.456.com/server.php，可以写一个接口www.123.com/server.php，由这个接口在后端去调用www.456.com/server.php并拿到返回值，然后再返回给index.html，这就是一个代理的模式。相当于绕过了浏览器端，自然就不存在跨域问题。</span><br><span class="line"></span><br><span class="line">3、端修改header（XHR2方式）</span><br><span class="line">header(&apos;Access-Control-Allow-Origin:*&apos;);//允许所有来源访问</span><br><span class="line">header(&apos;Access-Control-Allow-Method:POST,GET&apos;);//允许访问的方式</span><br></pre></td></tr></table></figure>
<h4 id="session-分布式处理"><a href="#session-分布式处理" class="headerlink" title="session 分布式处理"></a>session 分布式处理</h4><p><a href="https://www.cnblogs.com/study-everyday/p/7853145.html" target="_blank" rel="noopener">分布式系统session一致性问题</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">目前的处理方式有以下几种： </span><br><span class="line">1、session黏性。就是说，用户在访问了某台服务器后，之后的操作就让其只走该服务器就好。那么久可以让用户只访问该台机器了。 </span><br><span class="line">eg:nginx配置</span><br><span class="line"></span><br><span class="line">upstream <span class="built_in">test</span>&#123;</span><br><span class="line">    <span class="comment">#这里添加的是上面启动好的两台服务器</span></span><br><span class="line">    ip_hash;<span class="comment">#粘性Session</span></span><br><span class="line">     server 192.168.22.229:8080 weight=1;</span><br><span class="line">     server 192.168.22.230:8080 weight=1;</span><br><span class="line">&#125;</span><br><span class="line">优点：操作简单，不用对session做任何操作 </span><br><span class="line">缺点：当一台机器挂掉后，流量切向其他的机器。会丢失部分用户的session </span><br><span class="line">适用场景：发生故障对客户产生的影响较小；服务器发生故障是低概率事件。</span><br><span class="line"></span><br><span class="line">2、使用广播的方式 </span><br><span class="line">当一台服务器中的session中（增删改）了之后，将这个session中的所有数据，通过广播一样的方式，同步到其他的服务器中去。 </span><br><span class="line">优点：容错性增高 </span><br><span class="line">缺点：机器不能太多，session数量不能太大，否则会造成网络阻塞，是服务器变慢。</span><br><span class="line"></span><br><span class="line">3、使用中间件共享session </span><br><span class="line">使用redis或者Memcached去当做有个中间件，session中的数据存放在其中。这里需要的是redis或者Memcached必须是集群。 </span><br><span class="line">两种做法： </span><br><span class="line">（1）黏性：说白了就是，和第一种方式一样，一个用户的请求只走一个服务器并且在拿session数据的时候，都只在该台服务器上，但是用户的session需要保存在redis上，作为备份（容灾用）。当一台服务器挂掉了，那么就可以将该用户的session复制到其他的机器上并且把流量转发。 </span><br><span class="line">（1）非黏性：这种情况下，就是将用户的session存放在redis上，用户在访问的时候，读取修改都在redis上 </span><br><span class="line">目前这种做法是大家使用最多的方法</span><br><span class="line"></span><br><span class="line">4、session数据存放数据库中 </span><br><span class="line">这种方法的优缺点大家都知道的。 </span><br><span class="line">优点：数据可以持久化，服务器挂掉了也没关系。 </span><br><span class="line">缺点：慢慢慢！！！而且用户过多的时候，性能低下。</span><br></pre></td></tr></table></figure>
<h4 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h4><p><a href="https://segmentfault.com/a/1190000004492447" target="_blank" rel="noopener">负载均衡算法及手段</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">算法：</span><br><span class="line">   1、随机算法</span><br><span class="line">        -| Random</span><br><span class="line">        -| WeightRandom</span><br><span class="line">    2、轮询及加权轮询</span><br><span class="line">    3、最小连接及加权最小连接</span><br><span class="line">    4、哈希算法</span><br><span class="line">        -| 普通hash</span><br><span class="line">        -| 一致性hash：相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</span><br><span class="line">    5、IP地址散列</span><br><span class="line">    6、URL散列</span><br><span class="line">    </span><br><span class="line">手段：(DNS-&gt;数据链路层-&gt;IP层-&gt;Http层)</span><br><span class="line">	1、DNS域名解析负载均衡(延迟)</span><br><span class="line">	2、数据链路层负载均衡(LVS) (又名：直接路由方式DR)</span><br><span class="line">	3、IP负载均衡(SNAT) (网络层)</span><br><span class="line">	4、HTTP重定向负载均衡(少见)</span><br><span class="line">	5、反向代理负载均衡(nginx)</span><br></pre></td></tr></table></figure>
<h4 id="OSI七层模型与TCP-IP五层模型"><a href="#OSI七层模型与TCP-IP五层模型" class="headerlink" title="OSI七层模型与TCP/IP五层模型"></a>OSI七层模型与TCP/IP五层模型</h4><p><a href="https://www.cnblogs.com/qishui/p/5428938.html" target="_blank" rel="noopener">OSI七层模型与TCP/IP五层模型</a></p>
<p><a href="https://blog.csdn.net/wdkirchhoff/article/details/43915825" target="_blank" rel="noopener">以太网帧结构</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> OSI（Open System Interconnect），即开放式系统互联。</span><br><span class="line"> </span><br><span class="line">应用层：为应用程序提供网络服务</span><br><span class="line">表示层：数据格式化，加密、解密</span><br><span class="line">会话层：建立、维护、管理会话连接</span><br><span class="line">传输层：建立、维护、管理端到端连接</span><br><span class="line">网络层：IP寻址和路由选择</span><br><span class="line">数据链路层：控制网络层与物理层之间通信</span><br><span class="line">物理层：传输比特流。</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fs7it04di3j30ra0es75v.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">各层功能定义</span><br><span class="line">        这里我们只对OSI各层进行功能上的大概阐述，不详细深究，因为每一层实际都是一个复杂的层。后面我也会根据个人方向展开部分层的深入学习。这里我们就大概了解一下。我们从最顶层——应用层 开始介绍。整个过程以公司A和公司B的一次商业报价单发送为例子进行讲解。</span><br><span class="line">&lt;1&gt;    应用层</span><br><span class="line">        HTTP，HTTPS，FTP，POP3、SMTP等。</span><br><span class="line">&lt;2&gt;    表示层</span><br><span class="line">        表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</span><br><span class="line">&lt;3&gt;    会话层</span><br><span class="line">        会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。      </span><br><span class="line">&lt;4&gt;   传输层</span><br><span class="line">        传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。</span><br><span class="line">&lt;5&gt;   网络层</span><br><span class="line">       本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。</span><br><span class="line">&lt;6&gt;   数据链路层 </span><br><span class="line">        将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。</span><br><span class="line">     数据链路层又分为2个子层：逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。</span><br><span class="line"></span><br><span class="line">        MAC子层处理CSMA/CD算法、数据出错校验、成帧等；LLC子层定义了一些字段使上次协议能共享数据链路层。 在实际使用中，LLC子层并非必需的。</span><br><span class="line"></span><br><span class="line">        这个没找到合适的例子</span><br><span class="line"></span><br><span class="line">&lt;7&gt;  物理层     </span><br><span class="line"></span><br><span class="line">        实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</span><br><span class="line">         快递寄送过程中的交通工具，就相当于我们的物理层，例如汽车，火车，飞机，船。</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fs7j917ta6j312k0erwga.jpg" alt=""></p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fs7ja2kuo1j314o0erabx.jpg" alt=""></p>
<h4 id="JDBC-流程"><a href="#JDBC-流程" class="headerlink" title="JDBC 流程"></a>JDBC 流程</h4><blockquote>
<p>第一步：加载Driver类，注册数据库驱动；<br>第二步：通过DriverManager,使用url，用户名和密码建立连接(Connection)；<br>第三步：通过Connection，使用sql语句打开Statement对象；<br>第四步：执行语句，将结果返回resultSet；<br>第五步：对结果resultSet进行处理；<br>第六步：倒叙释放资源resultSet-》preparedStatement-》connection。</p>
</blockquote>
<h4 id="Mysql两种引擎"><a href="#Mysql两种引擎" class="headerlink" title="Mysql两种引擎"></a>Mysql两种引擎</h4><p><a href="https://www.cnblogs.com/xiaohaillong/p/6079551.html" target="_blank" rel="noopener">Mysql常用引擎</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ACID，指数据库事务正确执行的四个基本要素的缩写。包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）</span><br><span class="line"></span><br><span class="line">在MySQL数据库中，常用的引擎主要就是2个：Innodb和MyIASM。</span><br><span class="line"></span><br><span class="line">首先：</span><br><span class="line"></span><br><span class="line">1.简单介绍这两种引擎，以及该如何去选择。</span><br><span class="line">2.这两种引擎所使用的数据结构是什么。</span><br><span class="line"></span><br><span class="line">1.</span><br><span class="line"></span><br><span class="line">a.Innodb引擎，Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。它本身实际上是基于Mysql后台的完整的系统。Mysql运行的时候，Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是，该引擎是不支持全文搜索的。同时，启动也比较的慢，它是不会保存表的行数的。当进行Select count(*) from table指令的时候，需要进行扫描全表。所以当需要使用数据库的事务时，该引擎就是首选。由于锁的粒度小，写操作是不会锁定全表的。所以在并发度较高的场景下使用会提升效率的。</span><br><span class="line"></span><br><span class="line">b.MyIASM引擎，它是MySql的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行Insert插入和Update更新语句时，即执行写操作的时候需要锁定这个表。所以会导致效率会降低。不过和Innodb不同的是，MyIASM引擎是保存了表的行数，于是当进行Select count(*) from table语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的。可以将MyIASM作为数据库引擎的首先。</span><br><span class="line"></span><br><span class="line">补充2点：</span><br><span class="line"></span><br><span class="line">c.大容量的数据集时趋向于选择Innodb。因为它支持事务处理和故障的恢复。Innodb可以利用数据日志来进行数据的恢复。主键的查询在Innodb也是比较快的。</span><br><span class="line"></span><br><span class="line">d.大批量的插入语句时（这里是INSERT语句）在MyIASM引擎中执行的比较的快，但是UPDATE语句在Innodb下执行的会比较的快，尤其是在并发量大的时候。</span><br><span class="line"></span><br><span class="line">2.两种引擎所使用的索引的数据结构是什么？</span><br><span class="line"></span><br><span class="line">答案:都是B+树!</span><br><span class="line"></span><br><span class="line">MyIASM引擎，B+树的数据结构中存储的内容实际上是实际数据的地址值。也就是说它的索引和实际数据是分开的，只不过使用索引指向了实际数据。这种索引的模式被称为非聚集索引。</span><br><span class="line"></span><br><span class="line">Innodb引擎的索引的数据结构也是B+树，只不过数据结构中存储的都是实际的数据，这种索引有被称为聚集索引。</span><br></pre></td></tr></table></figure>
<p>MVC 设计思想</p>
<h4 id="equals-与-的区别"><a href="#equals-与-的区别" class="headerlink" title="equals 与 == 的区别"></a>equals 与 == 的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">== : 比较地址(引用)</span><br><span class="line">equals : 对象内容</span><br></pre></td></tr></table></figure>
<h4 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h4><p><a href="http://jinnianshilongnian.iteye.com/blog/2305117" target="_blank" rel="noopener">限流实现方案</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常见的限流算法有：令牌桶、漏桶。计数器也可以进行粗暴限流实现。</span><br></pre></td></tr></table></figure>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="List-和-Set-区别"><a href="#List-和-Set-区别" class="headerlink" title="List 和 Set 区别"></a>List 和 Set 区别</h4><h4 id="List-和-Map-区别"><a href="#List-和-Map-区别" class="headerlink" title="List 和 Map 区别"></a>List 和 Map 区别</h4><h4 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别"></a>Arraylist 与 LinkedList 区别</h4><h4 id="ArrayList-与-Vector-区别"><a href="#ArrayList-与-Vector-区别" class="headerlink" title="ArrayList 与 Vector 区别"></a>ArrayList 与 Vector 区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）  Vector的方法都是同步的(Synchronized),是线程安全的(thread-safe)，而ArrayList的方法不是，由于线程的同步必然要影响性能，因此,ArrayList的性能比Vector好。 </span><br><span class="line">2） 当Vector或ArrayList中的元素超过它的初始大小时,Vector会将它的容量翻倍,而ArrayList只增加50%的大小，这样,ArrayList就有利于节约内存空间。</span><br></pre></td></tr></table></figure>
<h4 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h4><p><a href="https://blog.csdn.net/wangxing233/article/details/79452946" target="_blank" rel="noopener">HashMap与Hashtable</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Hashtable:  key &amp; value 都不能为null。方法层面Synchronize保证线程安全</span><br><span class="line">HashMap: key可以为null(唯一)，value可以为null。非ss线程安全</span><br><span class="line">ConcurrentHashMap： 分段锁🔐</span><br><span class="line"></span><br><span class="line">HashMap的Iterator是fail-fast迭代器(当有其它线程改变了HashMap的结构（增加，删除，修改元素），将会抛出ConcurrentModificationException。不过，通过Iterator的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM)</span><br><span class="line">JDK8之前的版本中，Hashtable是没有fast-fail机制的。在JDK8及以后的版本中 ，HashTable也是使用fast-fail的</span><br><span class="line"></span><br><span class="line">Hashtable默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。</span><br><span class="line">Hashtable在计算元素的位置时需要进行一次除法运算，而除法运算是比较耗时的。 </span><br><span class="line">HashMap为了提高计算效率，将哈希表的大小固定为了2的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。</span><br></pre></td></tr></table></figure>
<h4 id="HashSet-和-HashMap-区别"><a href="#HashSet-和-HashMap-区别" class="headerlink" title="HashSet 和 HashMap 区别"></a>HashSet 和 HashMap 区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashSet使用HashMap存储数据</span><br></pre></td></tr></table></figure>
<h4 id="HashMap-和-ConcurrentHashMap-的区别"><a href="#HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别"></a>HashMap 和 ConcurrentHashMap 的区别</h4><p><a href="http://www.importnew.com/28263.html" target="_blank" rel="noopener">Java7&amp;Java8中HashMap&amp;ConcurrentHashMap</a></p>
<h4 id="HashMap-的工作原理及代码实现"><a href="#HashMap-的工作原理及代码实现" class="headerlink" title="HashMap 的工作原理及代码实现"></a>HashMap 的工作原理及代码实现</h4><p><a href="http://www.cnblogs.com/chengxiao/p/6059914.html" target="_blank" rel="noopener">HashMap</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">哈希冲突的解决方案有多种:(https://www.cnblogs.com/wuchaodzxx/p/7396599.html)</span><br><span class="line">	-| 开放定址法（再散列法）（发生冲突，继续寻找下一块未被占用的存储地址），</span><br><span class="line">		H0 = H(key)</span><br><span class="line">		Hi = (H(key)+di) MOD m</span><br><span class="line">		-| 线性探测再散列</span><br><span class="line">		-| 平方（二次）探测再散列</span><br><span class="line">		-| 伪随机探测再散列</span><br><span class="line">	-| 再哈希法(多个哈希函数)</span><br><span class="line">	-| 链地址法，HashMap</span><br><span class="line">	-| 建立公共溢出区</span><br><span class="line">		这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</span><br><span class="line">而HashMap即是采用了链地址法，也就是数组+链表的方式，</span><br></pre></td></tr></table></figure>
<h4 id="ConcurrentHashMap-的工作原理及代码实现"><a href="#ConcurrentHashMap-的工作原理及代码实现" class="headerlink" title="ConcurrentHashMap 的工作原理及代码实现"></a>ConcurrentHashMap 的工作原理及代码实现</h4><p><a href="https://www.cnblogs.com/chengxiao/p/6842045.html" target="_blank" rel="noopener">ConcurrentHashMap</a></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="创建线程的方式及实现"><a href="#创建线程的方式及实现" class="headerlink" title="创建线程的方式及实现"></a>创建线程的方式及实现</h4><h4 id="sleep-、join（）、yield（）有什么区别"><a href="#sleep-、join（）、yield（）有什么区别" class="headerlink" title="sleep() 、join（）、yield（）有什么区别"></a>sleep() 、join（）、yield（）有什么区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.sleep()方法</span><br><span class="line"></span><br><span class="line">在指定时间内让当前正在执行的线程暂停执行，但不会释放“锁标志”。不推荐使用。</span><br><span class="line"></span><br><span class="line">sleep()使当前线程进入阻塞状态，在指定时间内不会执行。</span><br><span class="line"></span><br><span class="line">2.wait()方法</span><br><span class="line"></span><br><span class="line">在其他线程调用对象的notify或notifyAll方法前，导致当前线程等待。线程会释放掉它所占有的“锁标志”，从而使别的线程有机会抢占该锁。</span><br><span class="line"></span><br><span class="line">当前线程必须拥有当前对象锁。如果当前线程不是此锁的拥有者，会抛出IllegalMonitorStateException异常。</span><br><span class="line"></span><br><span class="line">唤醒当前对象锁的等待线程使用notify或notifyAll方法，也必须拥有相同的对象锁，否则也会抛出IllegalMonitorStateException异常。</span><br><span class="line"></span><br><span class="line">waite()和notify()必须在synchronized函数或synchronized　block中进行调用。如果在non-synchronized函数或non-synchronized　block中进行调用，虽然能编译通过，但在运行时会发生IllegalMonitorStateException的异常。</span><br><span class="line"></span><br><span class="line">3.yield方法</span><br><span class="line"></span><br><span class="line">暂停当前正在执行的线程对象。</span><br><span class="line"></span><br><span class="line">yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。</span><br><span class="line"></span><br><span class="line">yield()只能使同优先级或更高优先级的线程有执行的机会。 </span><br><span class="line"></span><br><span class="line">4.join方法</span><br><span class="line"></span><br><span class="line">等待该线程终止。</span><br><span class="line"></span><br><span class="line">等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。</span><br></pre></td></tr></table></figure>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重入锁，</span><br><span class="line">又叫排他锁</span><br></pre></td></tr></table></figure>
<h4 id="说说-CountDownLatch-原理"><a href="#说说-CountDownLatch-原理" class="headerlink" title="说说 CountDownLatch 原理"></a>说说 CountDownLatch 原理</h4><blockquote>
<p>在java5提供的并发包下，有一个AbstractQueuedSynchronizer抽象类，也叫AQS，此类根据大部分并发共性作了一些抽象，便于开发者实现如排他锁，共享锁，条件等待等更高级的业务功能。它通过使用CAS和队列模型，出色的完成了抽象任务，在此向Doug Lea致敬。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-| 共享锁，状态传递，唤醒后面的任务</span><br><span class="line">-| 闭锁</span><br></pre></td></tr></table></figure>
<h4 id="说说-CyclicBarrier-原理"><a href="#说说-CyclicBarrier-原理" class="headerlink" title="说说 CyclicBarrier 原理"></a>说说 CyclicBarrier 原理</h4><blockquote>
<p>可重入</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">多个线程等待 同时启动</span><br><span class="line">-| 可以用CountDownLatch实现，先countDown()，再await()</span><br></pre></td></tr></table></figure>
<h4 id="说说-Semaphore-原理"><a href="#说说-Semaphore-原理" class="headerlink" title="说说 Semaphore 原理"></a>说说 Semaphore 原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">多窗口购票问题</span><br><span class="line"></span><br><span class="line">--- </span><br><span class="line">和限流算法中 桶令牌算法 如出一辙？</span><br></pre></td></tr></table></figure>
<h4 id="说说-Exchanger-原理"><a href="#说说-Exchanger-原理" class="headerlink" title="说说 Exchanger 原理"></a>说说 Exchanger 原理</h4><blockquote>
<p>jdk1.5</p>
<p><a href="https://blog.csdn.net/coslay/article/details/45242581" target="_blank" rel="noopener">java Exchanger原理</a></p>
<ul>
<li>此类提供对外的操作是同步的；</li>
<li>用于成对出现的线程之间交换数据；</li>
<li>可以视作双向的同步队列；</li>
<li>可应用于基因算法、流水线设计等场景。</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="说说-CountDownLatch-与-CyclicBarrier-区别"><a href="#说说-CountDownLatch-与-CyclicBarrier-区别" class="headerlink" title="说说 CountDownLatch 与 CyclicBarrier 区别"></a>说说 CountDownLatch 与 CyclicBarrier 区别</h4><table>
<thead>
<tr>
<th>CountDownLatch</th>
<th>CyclicBarrier</th>
</tr>
</thead>
<tbody>
<tr>
<td>减计数方式</td>
<td>加计数方式</td>
</tr>
<tr>
<td>计算为0时释放所有等待的线程</td>
<td>计数达到指定值时释放所有等待线程</td>
</tr>
<tr>
<td>计数为0时，无法重置</td>
<td>计数达到指定值时，计数置为0重新开始</td>
</tr>
<tr>
<td>调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响</td>
<td>调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞</td>
</tr>
<tr>
<td>不可重复利用</td>
<td>可重复利用</td>
</tr>
</tbody>
</table>
<h4 id="ThreadLocal-原理分析"><a href="#ThreadLocal-原理分析" class="headerlink" title="ThreadLocal 原理分析"></a>ThreadLocal 原理分析</h4><blockquote>
<p><a href="https://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="noopener">深入剖析ThreadLocal</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap.Entry extend WeakReference&lt;ThreadLocal&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="讲讲线程池的实现原理"><a href="#讲讲线程池的实现原理" class="headerlink" title="讲讲线程池的实现原理"></a>讲讲线程池的实现原理</h4><blockquote>
<p>ThreadPoolExecutor类构造器语法形式：</p>
<p>ThreadPoolExecutor（corePoolSize,maxPoolSize,keepAliveTime,timeUnit,workQueue,threadFactory,handle);   </p>
<p>方法参数：<br>　  <strong>corePoolSize：核心线程数</strong><br>　  <strong>maxPoolSize：最大线程数</strong><br>     <strong>keepAliveTime：线程存活时间（在corePore&lt;*&lt;maxPoolSize情况下有用）</strong><br>     <strong>timeUnit：存活时间的时间单位</strong><br>     <strong>workQueue：阻塞队列（用来保存等待被执行的任务）</strong></p>
<p>注：关于workQueue参数的取值,JDK提供了4种阻塞队列类型供选择：<br>　　      <em>ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务；</em><br>　　     <em>LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于</em>  </p>
<p>​            <em>SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于ArrayBlockingQuene；</em></p>
<p>　　      <em>PriorityBlockingQuene：具有优先级的无界阻塞队列</em>；</p>
<p>​     <strong>threadFactory：线程工厂，主要用来创建线程；</strong></p>
<p>​     <strong>handler：表示当拒绝处理任务时的策略，有以下四种取值</strong></p>
<p> 注： 当线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：</p>
<p>　　　　<em>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</em></p>
<p>　　　　<em>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</em></p>
<p>　　　　<em>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</em></p>
<p>　　　　<em>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</em></p>
<p>　　　　<em>当然也可以根据应用场景实现*<em>RejectedExecutionHandler*</em>接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</em></p>
</blockquote>
<h4 id="线程池的几种方式与使用场景"><a href="#线程池的几种方式与使用场景" class="headerlink" title="线程池的几种方式与使用场景"></a>线程池的几种方式与使用场景</h4><blockquote>
<p><strong>newFixedThreadPool()</strong><br>说明：初始化一个指定线程数的线程池，其中corePoolSize == maxiPoolSize，使用LinkedBlockingQuene作为阻塞队列<br>特点：即使当线程池没有可执行任务时，也不会释放线程。<br><strong>newCachedThreadPool()</strong><br>说明：初始化一个可以缓存线程的线程池，默认缓存60s，线程池的线程数可达到Integer.MAX_VALUE，即2147483647，内部使用SynchronousQueue作为阻塞队列；<br>特点：在没有任务执行时，当线程的空闲时间超过keepAliveTime，会自动释放线程资源；当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销；<br>因此，使用时要注意控制并发的任务数，防止因创建大量的线程导致而降低性能。<br><strong>newSingleThreadExecutor()</strong><br>说明：初始化只有一个线程的线程池，内部使用LinkedBlockingQueue作为阻塞队列。<br>特点：如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行<br><strong>newScheduledThreadPool()</strong><br>特定：初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据。</p>
<p>总结：除了newScheduledThreadPool的内部实现特殊一点之外，其它线程池内部都是基于<strong>ThreadPoolExecutor</strong>类（Executor的子类）实现的。</p>
</blockquote>
<h4 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h4><blockquote>
<p>分治法</p>
</blockquote>
<h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h4><blockquote>
<p>其中AtomicInteger变量ctl的功能非常强大：利用低29位表示线程池中线程数，通过高3位表示线程池的运行状态：<br>1、<strong>RUNNING</strong>：-1 &lt;&lt; COUNT_BITS，即高3位为111，该状态的线程池会接收新任务，并处理阻塞队列中的任务；<br>2、<strong>SHUTDOWN</strong>： 0 &lt;&lt; COUNT_BITS，即高3位为000，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；<br>3、<strong>STOP</strong> ： 1 &lt;&lt; COUNT_BITS，即高3位为001，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；<br>4、<strong>TIDYING</strong> ： 2 &lt;&lt; COUNT_BITS，即高3位为010，该状态表示线程池对线程进行整理优化；<br>5、<strong>TERMINATED</strong>： 3 &lt;&lt; COUNT_BITS，即高3位为011，该状态表示线程池停止工作；</p>
</blockquote>
<h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><h4 id="说说线程安全问题"><a href="#说说线程安全问题" class="headerlink" title="说说线程安全问题"></a>说说线程安全问题</h4><h4 id="volatile-实现原理"><a href="#volatile-实现原理" class="headerlink" title="volatile 实现原理"></a>volatile 实现原理</h4><blockquote>
<p><a href="http://ifeve.com/volatile/" target="_blank" rel="noopener">Volatile</a></p>
<p>Java语言规范第三版中对volatile的定义如下： java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p>
<ul>
<li>将当前处理器缓存行的数据会写回到系统内存。</li>
<li>这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。</li>
</ul>
</blockquote>
<h4 id="CPU高速缓存（L1-L2-L3）"><a href="#CPU高速缓存（L1-L2-L3）" class="headerlink" title="CPU高速缓存（L1,L2,L3）"></a>CPU高速缓存（L1,L2,L3）</h4><blockquote>
<p><a href="https://blog.csdn.net/myxmu/article/details/17021975" target="_blank" rel="noopener">CPU的缓存</a></p>
<p>为了保证CPU访问时有较高的命中率，Cache中的内容应该按一定的算法替换。一种较常用的算法是“最近最少使用算法”（LRU算法）</p>
</blockquote>
<h4 id="synchronize-实现原理"><a href="#synchronize-实现原理" class="headerlink" title="synchronize 实现原理"></a>synchronize 实现原理</h4><blockquote>
<p><a href="http://www.importnew.com/23511.html" target="_blank" rel="noopener">实现原理</a></p>
</blockquote>
<h4 id="synchronized-与-lock-的区别"><a href="#synchronized-与-lock-的区别" class="headerlink" title="synchronized 与 lock 的区别"></a>synchronized 与 lock 的区别</h4><blockquote>
<p>0</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">两者区别：</span><br><span class="line"></span><br><span class="line">1.首先synchronized是java内置关键字，在jvm层面，Lock是个java类；</span><br><span class="line"></span><br><span class="line">2.synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</span><br><span class="line"></span><br><span class="line">3.synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</span><br><span class="line"></span><br><span class="line">4.用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</span><br><span class="line"></span><br><span class="line">5.synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）</span><br><span class="line"></span><br><span class="line">6.Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</span><br></pre></td></tr></table></figure>
<h4 id="CAS-乐观锁"><a href="#CAS-乐观锁" class="headerlink" title="CAS 乐观锁"></a>CAS 乐观锁</h4><blockquote>
<p><a href="https://www.cnblogs.com/qjjazry/p/6581568.html" target="_blank" rel="noopener">乐观锁与悲观锁，以及乐观锁实现CAS</a></p>
<p>　悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。</p>
<p>　　乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p>
</blockquote>
<h4 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h4><blockquote>
<p>在Java中，AtomicStampedReference也实现了这个作用，它通过包装[E,Integer]的元组来对对象标记版本戳stamp，从而避免ABA问题，例如下面的代码分别用AtomicInteger和AtomicStampedReference来对初始值为100的原子整型变量进行更新，AtomicInteger会成功执行CAS操作，而加上版本戳的AtomicStampedReference对于ABA问题会执行CAS失败：</p>
</blockquote>
<h4 id="乐观锁的业务场景及实现方式"><a href="#乐观锁的业务场景及实现方式" class="headerlink" title="乐观锁的业务场景及实现方式"></a>乐观锁的业务场景及实现方式</h4><blockquote>
<p>乐观锁是在应用层加锁，而悲观锁是在数据库层加锁(for update)</p>
<p>乐观锁顾名思义就是在操作时很乐观，这数据只有我在用，我先尽管用，最后发现不行时就回滚。</p>
<p>悲观锁在操作时很悲观，生怕数据被其他人更新掉，我就先将其先锁住，让别人用不了，我操作完成后再释放掉。</p>
<p>悲观锁需要数据库级别上的的实现，程序中是做不到的，如果在长事务环境中，数据会一直被锁住，导致并发性能大大地降低。</p>
<p>一般来说如果并发量很高的话，建议使用悲观锁，否则的话就使用乐观锁。</p>
<p>如果并发量很高时使用乐观锁的话，会导致很多的并发事务回滚、操作失败。</p>
<p>总之，冲突几率大用悲观，小就用乐观。</p>
</blockquote>
<h2 id="核心篇"><a href="#核心篇" class="headerlink" title="核心篇"></a>核心篇</h2><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><h4 id="MySQL-索引使用的注意事项"><a href="#MySQL-索引使用的注意事项" class="headerlink" title="MySQL 索引使用的注意事项"></a><a href="http://blog.720ui.com/2017/mysql_core_04_index_item/" target="_blank" rel="noopener">MySQL 索引使用的注意事项</a></h4><blockquote>
<ul>
<li>-不要在列上使用函数和进行计算</li>
<li>-尽量避免使用 != 或 not in或 &lt;&gt; 等否定操作符</li>
<li>-尽量避免使用 or 来连接条件</li>
<li>-多个单列索引并不是最佳选择</li>
<li>-复合索引的最左前缀原则</li>
<li>-覆盖索引的好处</li>
<li>-范围查询对多列查询的影响</li>
<li>-索引不会包含有NULL值的列</li>
<li>-隐式转换的影响</li>
<li>-like 语句的索引失效问题</li>
</ul>
</blockquote>
<h4 id="说说反模式设计"><a href="#说说反模式设计" class="headerlink" title="说说反模式设计"></a><a href="http://blog.720ui.com/2017/mysql_core_07_anti-pattern/" target="_blank" rel="noopener">说说反模式设计</a></h4><p><code>反范式设计</code></p>
<blockquote>
<p>数据库范式是为解决关系数据库中数据冗余、更新异常、插入异常、删除异常问题而引入的。简单的理解，数据库范式可以避免数据冗余，减少数据库的空间，并且减轻维护数据完整性的麻烦。</p>
</blockquote>
<h4 id="说说分库与分表设计"><a href="#说说分库与分表设计" class="headerlink" title="说说分库与分表设计"></a><a href="http://blog.720ui.com/2017/mysql_core_08_multi_db_table/" target="_blank" rel="noopener">说说分库与分表设计</a></h4><h4 id="分库与分表带来的分布式困境与应对之策"><a href="#分库与分表带来的分布式困境与应对之策" class="headerlink" title="分库与分表带来的分布式困境与应对之策"></a><a href="http://blog.720ui.com/2017/mysql_core_09_multi_db_table2/" target="_blank" rel="noopener">分库与分表带来的分布式困境与应对之策</a></h4><h4 id="说说-SQL-优化之道"><a href="#说说-SQL-优化之道" class="headerlink" title="说说 SQL 优化之道"></a><a href="http://blog.720ui.com/2017/mysql_core_03_how_use_index/" target="_blank" rel="noopener">说说 SQL 优化之道</a></h4><h4 id="MySQL-遇到的死锁问题"><a href="#MySQL-遇到的死锁问题" class="headerlink" title="MySQL 遇到的死锁问题"></a>MySQL 遇到的死锁问题</h4><blockquote>
<p>在数据库中有两种基本的锁类型：排它锁（Exclusive Locks，即X锁）和共享锁（Share Locks，即S锁）。当数据对象被加上排它锁时，其他的事务不能对它读取和修改。加了共享锁的数据对象可以被其他事务读取，但不能修改。数据库利用这两 种基本的锁类型来对数据库的事务进行并发控制。</p>
</blockquote>
<h4 id="存储引擎的-InnoDB-与-MyISAM"><a href="#存储引擎的-InnoDB-与-MyISAM" class="headerlink" title="存储引擎的 InnoDB 与 MyISAM"></a><a href="http://blog.720ui.com/2017/mysql_core_02_innodb_myisam/" target="_blank" rel="noopener">存储引擎的 InnoDB 与 MyISAM</a></h4><h4 id="数据库索引的原理"><a href="#数据库索引的原理" class="headerlink" title="数据库索引的原理"></a>数据库索引的原理</h4><blockquote>
<p><a href="https://blog.csdn.net/suifeng3051/article/details/52669644" target="_blank" rel="noopener">数据库索引原理及优化</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">寻道时间是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下。</span><br><span class="line">旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms。</span><br><span class="line">传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。</span><br></pre></td></tr></table></figure>
<h4 id="为什么要用-B-tree"><a href="#为什么要用-B-tree" class="headerlink" title="为什么要用 B-tree"></a>为什么要用 B-tree</h4><blockquote>
<p>平衡多路搜索树B树（B-tree）,B树（Balance Tree）又叫做B- 树,它的搜索时间复杂度为<code>O(log2N)</code>，所以它的搜索效率和树的深度有关，如果要提高查询速度，那么就要降低树的深度。要降低树的深度，很自然的方法就是采用多叉树，再结合平衡二叉树的思想，我们可以构建一个平衡多叉树结构，然后就可以在上面构建平衡多路查找算法，提高大数据量下的搜索效率。</p>
</blockquote>
<h4 id="聚集索引与非聚集索引的区别"><a href="#聚集索引与非聚集索引的区别" class="headerlink" title="聚集索引与非聚集索引的区别"></a>聚集索引与非聚集索引的区别</h4><h4 id="limit-20000-加载很慢怎么解决"><a href="#limit-20000-加载很慢怎么解决" class="headerlink" title="limit 20000 加载很慢怎么解决"></a>limit 20000 加载很慢怎么解决</h4><blockquote>
<p>通过主键id做过滤，减少扫描行数</p>
</blockquote>
<p>#####选择合适的分布式主键方案</p>
<h4 id="选择合适的数据存储方案"><a href="#选择合适的数据存储方案" class="headerlink" title="选择合适的数据存储方案"></a><a href="http://blog.720ui.com/2017/db_better_db_use/" target="_blank" rel="noopener">选择合适的数据存储方案</a></h4><h4 id="ObjectId-规则"><a href="#ObjectId-规则" class="headerlink" title="ObjectId 规则"></a>ObjectId 规则</h4><blockquote>
<p>MongoDB中存储的文档必须有一个”_id” 。这个键值可以是任何类型，默认是ObjectID对象。在一个集合里，每个文档都有一个唯一的“_id”，确保集合里的每个文档都能被唯一标示。</p>
<p>ObjectID使用12字节的存储空间，是一个由24个16进制数字组成的字符串。</p>
<p>ObjectId的12个字节按照如下方式生成</p>
<p><img src="https://images2015.cnblogs.com/blog/563063/201705/563063-20170516142739682-838031095.png" alt="img"></p>
<p>时间戳：</p>
<p>　　时间戳，前四个字节是从标准纪元开始的时间戳，单位是秒。可提供秒级别的唯一性。</p>
<p>　　由于时间戳在前，这意味着ObjectId大致按照插入的顺序排列。</p>
<p>　　这四个字节也隐含了文档的创建时间。</p>
<p>机器：</p>
<p>　　主机的唯一标识符。通常是机器主机的散列值（hash）。这样可以确保不同的机器生成不同的ObjectId　　</p>
<p>PID：</p>
<p>　　为了确保在同一台机器上并发的多个进程产生的ObjectID是唯一的，接下来者两个字节产生来自于进程的标识符</p>
<p>计数器：</p>
<p>　　最后三个字节是一个自动增加的计数器，确保相同的进程同一秒产生的ObjectId也是不一样的一秒钟最多允许每个进程拥有2563个不同的ObjectId</p>
</blockquote>
<h4 id="聊聊-MongoDB-使用场景"><a href="#聊聊-MongoDB-使用场景" class="headerlink" title="聊聊 MongoDB 使用场景"></a><a href="http://blog.720ui.com/2017/mongodb_core_use/" target="_blank" rel="noopener">聊聊 MongoDB 使用场景</a></h4><h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><blockquote>
<p><a href="https://www.cnblogs.com/zlslch/p/6440114.html" target="_blank" rel="noopener">倒排索引</a></p>
<p>见其名知其意，有倒排索引，对应肯定，有正向索引。</p>
<p> 正向索引（forward index），反向索引（inverted index）更熟悉的名字是倒排索引。</p>
</blockquote>
<h4 id="聊聊-ElasticSearch-使用场景"><a href="#聊聊-ElasticSearch-使用场景" class="headerlink" title="聊聊 ElasticSearch 使用场景"></a>聊聊 ElasticSearch 使用场景</h4><h3 id="缓存使用"><a href="#缓存使用" class="headerlink" title="缓存使用"></a>缓存使用</h3><h4 id="Redis-有哪些类型"><a href="#Redis-有哪些类型" class="headerlink" title="Redis 有哪些类型"></a>Redis 有哪些类型</h4><h4 id="Redis-内部结构"><a href="#Redis-内部结构" class="headerlink" title="Redis 内部结构"></a>Redis 内部结构</h4><h4 id="Redis-内存淘汰机制"><a href="#Redis-内存淘汰机制" class="headerlink" title="Redis 内存淘汰机制"></a><a href="http://blog.720ui.com/2016/redis_action_02_maxmemory_policy/" target="_blank" rel="noopener">Redis 内存淘汰机制</a></h4><h4 id="聊聊-Redis-使用场景"><a href="#聊聊-Redis-使用场景" class="headerlink" title="聊聊 Redis 使用场景"></a><a href="http://blog.720ui.com/2017/redis_core_use/" target="_blank" rel="noopener">聊聊 Redis 使用场景</a></h4><h4 id="Redis-持久化机制"><a href="#Redis-持久化机制" class="headerlink" title="Redis 持久化机制"></a><a href="http://blog.720ui.com/2016/redis_action_03_rdb_aof/" target="_blank" rel="noopener">Redis 持久化机制</a></h4><h4 id="Redis-集群方案与实现"><a href="#Redis-集群方案与实现" class="headerlink" title="Redis 集群方案与实现"></a><a href="http://blog.720ui.com/2016/redis_action_04_cluster/" target="_blank" rel="noopener">Redis 集群方案与实现</a></h4><h4 id="Redis-为什么是单线程的"><a href="#Redis-为什么是单线程的" class="headerlink" title="Redis 为什么是单线程的"></a>Redis 为什么是单线程的</h4><blockquote>
<p>redis-sentinel  实现高可用。</p>
<ul>
<li>Twemproxy，redis代理实现集群（keepalived实现HA）</li>
</ul>
</blockquote>
<h4 id="缓存雪崩、穿透、预热、更新、降级等问题"><a href="#缓存雪崩、穿透、预热、更新、降级等问题" class="headerlink" title="缓存雪崩、穿透、预热、更新、降级等问题"></a>缓存雪崩、穿透、预热、更新、降级等问题</h4><blockquote>
<p><a href="https://blog.csdn.net/xlgen157387/article/details/79530877" target="_blank" rel="noopener">缓存相关问题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 雪崩：缓存大面积同时过期，库压力增大</span><br><span class="line">&gt; 穿透：缓存中没有，直接走路。（命中率的问题）。*布隆过滤器*，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</span><br><span class="line">&gt; 预热：接口出发预热，项目启动预热，定时刷新</span><br><span class="line">&gt; 更新：定期更新；请求出发更新</span><br><span class="line">&gt; 降级：自动降级 &amp; 人工降级</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="使用缓存的合理性问题"><a href="#使用缓存的合理性问题" class="headerlink" title="使用缓存的合理性问题"></a><a href="http://blog.720ui.com/2016/redis_action_01_use_core/" target="_blank" rel="noopener">使用缓存的合理性问题</a></h4><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><ul>
<li>消息队列的使用场景</li>
<li>消息的重发补偿解决思路</li>
<li>消息的幂等性解决思路（已解答，待补充）</li>
<li>消息的堆积解决思路</li>
<li>自己如何实现消息队列</li>
<li>如何保证消息的有序性</li>
</ul>
<h2 id="框架篇"><a href="#框架篇" class="headerlink" title="框架篇"></a>框架篇</h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><ul>
<li>BeanFactory 和 ApplicationContext 有什么区别</li>
<li>Spring Bean 的生命周期</li>
<li>Spring IOC 如何实现</li>
<li>说说 Spring AOP</li>
<li>Spring AOP 实现原理</li>
<li>动态代理（cglib 与 JDK）</li>
<li>Spring 事务实现方式</li>
<li>Spring 事务底层原理</li>
<li>如何自定义注解实现功能</li>
<li>Spring MVC 运行流程</li>
<li>Spring MVC 启动流程</li>
<li>Spring 的单例实现原理</li>
<li>Spring 框架中用到了哪些设计模式</li>
<li>Spring 其他产品（Srping Boot、Spring Cloud、Spring Secuirity、Spring Data、Spring AMQP 等）</li>
</ul>
<h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><ul>
<li>为什么选择 Netty</li>
<li>说说业务中，Netty 的使用场景</li>
<li>原生的 NIO 在 JDK 1.7 版本存在 epoll bug</li>
<li>什么是TCP 粘包/拆包</li>
<li>TCP粘包/拆包的解决办法</li>
<li>Netty 线程模型</li>
<li>说说 Netty 的零拷贝</li>
<li>Netty 内部执行流程</li>
<li>Netty 重连实现</li>
</ul>
<h2 id="微服务篇"><a href="#微服务篇" class="headerlink" title="微服务篇"></a>微服务篇</h2><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><ul>
<li><a href="http://blog.720ui.com/2016/arch_web_server/" target="_blank" rel="noopener">前后端分离是如何做的</a></li>
<li><a href="http://blog.720ui.com/2016/web_cross_domain/" target="_blank" rel="noopener">如何解决跨域</a></li>
<li>微服务哪些框架</li>
<li>你怎么理解 RPC 框架</li>
<li>说说 RPC 的实现原理</li>
<li>说说 Dubbo 的实现原理</li>
<li>你怎么理解 RESTful</li>
<li><a href="http://blog.720ui.com/2017/restful_api/" target="_blank" rel="noopener">说说如何设计一个良好的 API</a></li>
<li><a href="http://blog.720ui.com/2016/restful_idempotent/" target="_blank" rel="noopener">如何理解 RESTful API 的幂等性</a></li>
<li>如何保证接口的幂等性</li>
<li>说说 CAP 定理、 BASE 理论</li>
<li>怎么考虑数据一致性问题</li>
<li>说说最终一致性的实现方案</li>
<li><a href="http://blog.720ui.com/2017/msa_intro/" target="_blank" rel="noopener">你怎么看待微服务</a></li>
<li><a href="http://blog.720ui.com/2017/msa_soa/" target="_blank" rel="noopener">微服务与 SOA 的区别</a></li>
<li><a href="http://blog.720ui.com/2017/msa_design/" target="_blank" rel="noopener">如何拆分服务</a></li>
<li><a href="http://blog.720ui.com/2017/msa_design/" target="_blank" rel="noopener">微服务如何进行数据库管理</a></li>
<li><a href="http://blog.720ui.com/2017/msa_design/" target="_blank" rel="noopener">如何应对微服务的链式调用异常</a></li>
<li><a href="http://blog.720ui.com/2017/msa_design/" target="_blank" rel="noopener">对于快速追踪与定位问题</a></li>
<li><a href="http://blog.720ui.com/2017/msa_design/" target="_blank" rel="noopener">微服务的安全</a></li>
</ul>
<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><ul>
<li>谈谈业务中使用分布式的场景</li>
<li>Session 分布式方案</li>
<li>分布式锁的场景</li>
<li>分布是锁的实现方案</li>
<li>分布式事务</li>
<li>集群与负载均衡的算法与实现</li>
<li><a href="http://blog.720ui.com/2017/mysql_core_08_multi_db_table/" target="_blank" rel="noopener">说说分库与分表设计</a></li>
<li><a href="http://blog.720ui.com/2017/mysql_core_09_multi_db_table2/" target="_blank" rel="noopener">分库与分表带来的分布式困境与应对之策</a></li>
</ul>
<h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><ul>
<li><a href="http://blog.720ui.com/2017/security_stride/" target="_blank" rel="noopener">安全要素与 STRIDE 威胁</a></li>
<li><a href="http://blog.720ui.com/2016/security_web/" target="_blank" rel="noopener">防范常见的 Web 攻击</a></li>
<li><a href="http://blog.720ui.com/2016/security_data_transmission/" target="_blank" rel="noopener">服务端通信安全攻防</a></li>
<li><a href="http://blog.720ui.com/2016/security_https/" target="_blank" rel="noopener">HTTPS 原理剖析</a></li>
<li><a href="http://blog.720ui.com/2016/security_https_tls/" target="_blank" rel="noopener">HTTPS 降级攻击</a></li>
<li><a href="http://blog.720ui.com/2017/msa_oauth2/" target="_blank" rel="noopener">授权与认证</a></li>
<li><a href="http://blog.720ui.com/2017/msa_rbac/" target="_blank" rel="noopener">基于角色的访问控制</a></li>
<li><a href="http://blog.720ui.com/2017/msa_rbac_data/" target="_blank" rel="noopener">基于数据的访问控制</a></li>
</ul>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul>
<li>性能指标有哪些</li>
<li>如何发现性能瓶颈</li>
<li>性能调优的常见手段</li>
<li>说说你在项目中如何进行性能调优</li>
</ul>
<h2 id="工程篇"><a href="#工程篇" class="headerlink" title="工程篇"></a>工程篇</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ul>
<li>你如何对需求原型进行理解和拆分</li>
<li>说说你对功能性需求的理解</li>
<li>说说你对非功能性需求的理解</li>
<li>你针对产品提出哪些交互和改进意见</li>
<li>你如何理解用户痛点</li>
</ul>
<h3 id="设计能力"><a href="#设计能力" class="headerlink" title="设计能力"></a>设计能力</h3><ul>
<li>说说你在项目中使用过的 UML 图</li>
<li>你如何考虑组件化</li>
<li>你如何考虑服务化</li>
<li>你如何进行领域建模</li>
<li>你如何划分领域边界</li>
<li>说说你项目中的领域建模</li>
<li>说说概要设计</li>
</ul>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul>
<li>你项目中有使用哪些设计模式</li>
<li>说说常用开源框架中设计模式使用分析</li>
<li>说说你对设计原则的理解</li>
<li>23种设计模式的设计理念</li>
<li>设计模式之间的异同，例如策略模式与状态模式的区别</li>
<li>设计模式之间的结合，例如策略模式+简单工厂模式的实践</li>
<li>设计模式的性能，例如单例模式哪种性能更好。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yanxisir.com/2018/05/22/从spring-boot-autoconfigure入手/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yanxi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YanxiSir">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/22/从spring-boot-autoconfigure入手/" itemprop="url">从spring-boot-autoconfigure入手</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-22T20:30:26+08:00">
                2018-05-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="从spring-boot-autoconfigure入手"><a href="#从spring-boot-autoconfigure入手" class="headerlink" title="从spring-boot-autoconfigure入手"></a>从spring-boot-autoconfigure入手</h3><blockquote>
<p>ConfigurationPropertiesBindingPostProcessor会对标注@ConfigurationProperties注解的Bean进行属性值的配置</p>
</blockquote>
<h4 id="admin-spring-application-admin"><a href="#admin-spring-application-admin" class="headerlink" title="admin - [spring.application.admin]"></a>admin - [spring.application.admin]</h4><blockquote>
<p><em>JMX</em>（Java Management Extensions，即Java管理扩展）是一个为应用程序、设备、系统等植入管理功能的框架</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- SpringApplicationAdminJmxAutoConfiguration (Register a JMX component that allows to administer the current application. Intended <span class="keyword">for</span> internal use only.)</span><br><span class="line">    -| <span class="meta">@Configuration</span>  (自动配置Bean，一般和<span class="meta">@Bean</span>配合使用)</span><br><span class="line">    -| <span class="meta">@AutoConfigureAfter</span>(JmxAutoConfiguration.class)  (在指定的类初始化后再加载)</span><br><span class="line">    -| <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.application.admin"</span>, value = <span class="string">"enabled"</span>, havingValue = <span class="string">"true"</span>, matchIfMissing = <span class="keyword">false</span>)  (控制Configuration是否生效。此处为：当spring.application.admin.enabled=<span class="keyword">true</span> 生效，默认为<span class="keyword">false</span>)</span><br><span class="line">    -| <span class="meta">@ConditionalOnMissingBean</span> (当且仅当上下文不存在某个对象时，才会实例化一个Bean)</span><br><span class="line">    -| <span class="meta">@ConditionalOnBean</span>（仅仅在当前上下文中存在某个对象时，才会实例化一个Bean）</span><br><span class="line">    -| <span class="meta">@ConditionalOnClass</span>（某个<span class="class"><span class="keyword">class</span>位于类路径上，才会实例化一个<span class="title">Bean</span>）</span></span><br><span class="line"><span class="class">    -| @<span class="title">ConditionalOnExpression</span>（当表达式为<span class="title">true</span>的时候，才会实例化一个<span class="title">Bean</span>）</span></span><br><span class="line"><span class="class">    -| @<span class="title">ConditionalOnMissingClass</span>（某个<span class="title">class</span>类路径上不存在的时候，才会实例化一个<span class="title">Bean</span>）</span></span><br><span class="line"><span class="class">    -| @<span class="title">ConditionalOnNotWebApplication</span>（不是<span class="title">web</span>应用）</span></span><br></pre></td></tr></table></figure>
<h4 id="amqp-spring-rabbitmq"><a href="#amqp-spring-rabbitmq" class="headerlink" title="amqp - [spring.rabbitmq]"></a>amqp - [spring.rabbitmq]</h4><blockquote>
<p><em>AMQP</em>，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-| RabbitProperties (prefix=&quot;spring.rabbitmq&quot;, Configuration properties for Rabbit)</span><br><span class="line">-| RabbitAnnotationDrivenConfiguration </span><br><span class="line">    -| 初始化SimpleRabbitListenerContainerFactoryConfigurer、SimpleRabbitListenerContainerFactory、EnableRabbitConfiguration</span><br><span class="line">-| RabbitAutoConfiguration</span><br><span class="line">    -| @EnableConfigurationProperties</span><br><span class="line">    -| @Import</span><br></pre></td></tr></table></figure>
<h4 id="aop-spring-aop"><a href="#aop-spring-aop" class="headerlink" title="aop - [spring.aop]"></a>aop - [spring.aop]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-| AopAutoConfiguration</span><br><span class="line">    -| @ConditionalOnClass(&#123; EnableAspectJAutoProxy.class, Aspect.class, Advice.class &#125;)</span><br><span class="line">    -| @ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;auto&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span><br></pre></td></tr></table></figure>
<h4 id="batch-spring-batch"><a href="#batch-spring-batch" class="headerlink" title="batch - [spring.batch]"></a>batch - [spring.batch]</h4><blockquote>
<p><a href="http://blog.didispace.com/spring-batch-1/" target="_blank" rel="noopener">http://blog.didispace.com/spring-batch-1/</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-| BatchProperties ()</span><br><span class="line">    -| @ConfigurationProperties(prefix = &quot;spring.batch&quot;)(嵌套对象配置)</span><br><span class="line">-| ApplicationEvent</span><br><span class="line">    -| 事件订阅</span><br></pre></td></tr></table></figure>
<h4 id="cache-spring-cache"><a href="#cache-spring-cache" class="headerlink" title="cache - [spring.cache]"></a>cache - [spring.cache]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-| CacheAutoConfiguration</span><br><span class="line">    -| ImportSelector (可以自定义实例化bean)</span><br><span class="line">        -| 举例：@Import(EnableConfigurationPropertiesImportSelector.class)</span><br><span class="line">    -| SpringBootCondition (可以自定义@Conditional)</span><br><span class="line">        -| (@Conditional是SpringFramework的功能，SpringBoot在它的基础上定义了@ConditionalOnClass，@ConditionalOnProperty的一系列的注解来实现更丰富的内容。)</span><br><span class="line">    -| ConfigurationClassPostProcessor</span><br></pre></td></tr></table></figure>
<h4 id="cassandra-维基百科-spring-data-cassandra"><a href="#cassandra-维基百科-spring-data-cassandra" class="headerlink" title="cassandra (维基百科) - [spring.data.cassandra]"></a>cassandra (<a href="https://zh.wikipedia.org/wiki/Cassandra" target="_blank" rel="noopener">维基百科</a>) - [spring.data.cassandra]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// NoSQL</span><br><span class="line">-| CassandraAutoConfiguration</span><br><span class="line">-| CassandraProperties</span><br><span class="line">-| ClusterBuilderCustomizer</span><br></pre></td></tr></table></figure>
<h4 id="cloud-spring-cloud"><a href="#cloud-spring-cloud" class="headerlink" title="cloud - [spring.cloud]"></a>cloud - [spring.cloud]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-| CloudAutoConfiguration</span><br><span class="line">    -| @AutoConfigureAfter：在指定的配置类初始化后再加载 </span><br><span class="line">    -| @AutoConfigureBefore：在指定的配置类初始化前加载 </span><br><span class="line">    -| @AutoConfigureOrder：数越小越先初始化</span><br></pre></td></tr></table></figure>
<h4 id="condition"><a href="#condition" class="headerlink" title="condition -"></a>condition -</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">各种@Conditional注解</span><br></pre></td></tr></table></figure>
<h4 id="context-spring-messages"><a href="#context-spring-messages" class="headerlink" title="context - [spring.messages]"></a>context - [spring.messages]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-| ConfigurationPropertiesAutoConfiguration</span><br><span class="line">-| MessageSourceAutoConfiguration</span><br><span class="line">-| PropertyPlaceholderAutoConfiguration</span><br></pre></td></tr></table></figure>
<h4 id="、couchbase-spring-couchbase"><a href="#、couchbase-spring-couchbase" class="headerlink" title="、couchbase - [spring.couchbase]"></a>、couchbase - [spring.couchbase]</h4><p><em>Couchbase</em> 是一个具有高性能、可扩展性和可 用性强的数据库引擎(<a href="http://blog.jiguang.cn/couchbase_distributed_storage/" target="_blank" rel="noopener">Couchbase中的分布式存储</a>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-| CouchbaseAutoConfiguration</span><br><span class="line">-| CouchbaseProperties</span><br><span class="line">-| OnBootstrapHostsCondition</span><br></pre></td></tr></table></figure>
<h4 id="、dao-spring-dao-exceptiontranslation"><a href="#、dao-spring-dao-exceptiontranslation" class="headerlink" title="、dao - [spring.dao.exceptiontranslation]"></a>、dao - [spring.dao.exceptiontranslation]</h4><blockquote>
<p>是否开启PersistenceExceptionTranslationPostProcessor，默认为true,不用自己重复写了</p>
<p>将JavaSE异常转换为Spring的异常。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-| PersistenceExceptionTranslationAutoConfiguration</span><br></pre></td></tr></table></figure>
<h4 id="、data"><a href="#、data" class="headerlink" title="、data"></a>、data</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> cassandra - [spring.data.cassandra.repositories]</span><br><span class="line"> couchbase - [spring.data.couchbase]</span><br><span class="line"> elasticsearch - [spring.data.elasticsearch]</span><br><span class="line"> jpa - [spring.data.jpa.repositories]</span><br><span class="line"> ldap - [spring.data.ldap.repositories]  (https://segmentfault.com/a/1190000013026941) (LDAP（轻量级目录访问协议，Lightweight Directory Access Protocol)是实现提供被称为目录服务的信息服务。)</span><br><span class="line"> mongo - [spring.data.mongodb.repositories]</span><br><span class="line"> neo4j - [spring.data.neo4j] (图形数据库)</span><br><span class="line"> redis - [spring.redis]</span><br><span class="line"> rest - [spring.data.rest] (把 repository 自动输出为REST资源)</span><br><span class="line">    -| @RepositoryRestResource(path=&quot;xxx&quot;)</span><br><span class="line"> solr - [spring.data.solr.repositories] (Solr是一个高性能，采用Java5开发，基于Lucene的全文搜索服务器。)</span><br><span class="line">    -| </span><br><span class="line"></span><br><span class="line">-| AbstractRepositoryConfigurationSourceSupport</span><br></pre></td></tr></table></figure>
<h4 id="、diagnostics-analyzer"><a href="#、diagnostics-analyzer" class="headerlink" title="、diagnostics.analyzer"></a>、diagnostics.analyzer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-| NoSuchBeanDefinitionFailureAnalyzer</span><br></pre></td></tr></table></figure>
<h4 id="、domain"><a href="#、domain" class="headerlink" title="、domain"></a>、domain</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-| EntityScanner</span><br><span class="line">-| EntityScanPackages</span><br></pre></td></tr></table></figure>
<h4 id="、elasticsearch-jest-spring-elasticsearch-jest"><a href="#、elasticsearch-jest-spring-elasticsearch-jest" class="headerlink" title="、elasticsearch.jest - [spring.elasticsearch.jest]"></a>、elasticsearch.jest - [spring.elasticsearch.jest]</h4><blockquote>
<p>Jest是Elasticsearch 的Java Http Rest 客户端。</p>
<p>ElasticSearch已经具备应用于Elasticsearch内部的Java API，但是Jest弥补了ES自有API缺少Elasticsearch Http Rest接口客户端的不足。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-| HttpClientConfigBuilderCustomizer</span><br><span class="line">-| JestAutoConfiguration</span><br><span class="line">-| JestProperties</span><br></pre></td></tr></table></figure>
<h4 id="、flyway-flyway"><a href="#、flyway-flyway" class="headerlink" title="、flyway - [flyway]"></a>、flyway - [flyway]</h4><blockquote>
<p>Flyway是一款开源的数据库版本管理工具，它更倾向于规约优于配置的方式。</p>
<p><a href="https://blog.waterstrong.me/flyway-in-practice/" target="_blank" rel="noopener">快速掌握和使用flyway</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-| FlywayAutoConfiguration</span><br><span class="line">-| FlywayMigrationInitializer</span><br><span class="line">-| FlywayProperties</span><br></pre></td></tr></table></figure>
<h4 id="、freemarker-spring-freemarker"><a href="#、freemarker-spring-freemarker" class="headerlink" title="、freemarker - [spring.freemarker]"></a>、freemarker - [spring.freemarker]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-| FreeMarkerAutoConfiguration</span><br><span class="line">-| FreeMarkerProperties</span><br><span class="line">-| FreeMarkerTemplateAvailabilityProvider</span><br></pre></td></tr></table></figure>
<h4 id="、groovy-template-spring-groovy-template"><a href="#、groovy-template-spring-groovy-template" class="headerlink" title="、groovy.template - [spring.groovy.template]"></a>、groovy.template - [spring.groovy.template]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-| GroovyTemplateAutoConfiguration</span><br><span class="line">-| GroovyTemplateAvailabilityProvider</span><br><span class="line">-| GroovyTemplateProperties</span><br></pre></td></tr></table></figure>
<h4 id="、gson"><a href="#、gson" class="headerlink" title="、gson"></a>、gson</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-| GsonAutoConfiguration</span><br></pre></td></tr></table></figure>
<h4 id="、h2-spring-h2-console"><a href="#、h2-spring-h2-console" class="headerlink" title="、h2 - [spring.h2.console]"></a>、h2 - [spring.h2.console]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-| H2ConsoleAutoConfiguration</span><br><span class="line">-| H2ConsoleProperties</span><br></pre></td></tr></table></figure>
<h4 id="、hateoas-spring-hateoas"><a href="#、hateoas-spring-hateoas" class="headerlink" title="、hateoas - [spring.hateoas]"></a>、hateoas - [spring.hateoas]</h4><blockquote>
<p><a href="https://blog.csdn.net/u012557538/article/details/78706401" target="_blank" rel="noopener">hateoas约束</a></p>
<p>HATEOAS（Hypermedia as the engine of application state）是 REST 架构风格中最复杂的约束，也是构建成熟 REST 服务的核心。它的重要性在于打破了客户端和服务器之间严格的契约，使得客户端可以更加智能和自适应，而 REST 服务本身的演化和更新也变得更加容易。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-| HypermediaAutoConfiguration</span><br><span class="line">-| HateoasProperties</span><br><span class="line">-| HypermediaHttpMessageConverterConfiguration</span><br></pre></td></tr></table></figure>
<h4 id="、hazelcast-spring-hazelcast"><a href="#、hazelcast-spring-hazelcast" class="headerlink" title="、hazelcast - [spring.hazelcast]"></a>、hazelcast - [spring.hazelcast]</h4><blockquote>
<p><a href="https://www.cnblogs.com/garfieldcgf/p/6393579.html" target="_blank" rel="noopener">hazelcast初探</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-| HazelcastAutoConfiguration</span><br><span class="line">-| HazelcastConfigResourceCondition</span><br><span class="line">-| HazelcastInstanceFactory</span><br><span class="line">-| HazelcastJpaDependencyAutoConfiguration</span><br><span class="line">-| HazelcastProperties</span><br></pre></td></tr></table></figure>
<h4 id="、info-spring-info"><a href="#、info-spring-info" class="headerlink" title="、info - [spring.info]"></a>、info - [spring.info]</h4><blockquote>
<p>@TODO 待看</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="、integration-spring-jmx"><a href="#、integration-spring-jmx" class="headerlink" title="、integration - [spring.jmx]"></a>、integration - [spring.jmx]</h4><p><a href="https://blog.csdn.net/liubowin/article/details/51818613" target="_blank" rel="noopener">概述</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-| IntegrationAutoConfiguration</span><br><span class="line">-| IntegrationAutoConfigurationScanRegistrar</span><br></pre></td></tr></table></figure>
<h4 id="、jackson-spring-jackson"><a href="#、jackson-spring-jackson" class="headerlink" title="、jackson - [spring.jackson]"></a>、jackson - [spring.jackson]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-| JacksonProperties</span><br><span class="line">-| JacksonAutoConfiguration</span><br><span class="line">-| Jackson2ObjectMapperBuilderCustomizer</span><br></pre></td></tr></table></figure>
<h4 id="、jdbc-spring-datasource"><a href="#、jdbc-spring-datasource" class="headerlink" title="、jdbc - [spring.datasource]"></a>、jdbc - [spring.datasource]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="、jersey-spring-jersey"><a href="#、jersey-spring-jersey" class="headerlink" title="、jersey - [spring.jersey]"></a>、jersey - [spring.jersey]</h4><blockquote>
<p><em>Jersey</em> RESTful 框架是开源的RESTful框架, 实现了JAX-RS (JSR 311 &amp; JSR 339) 规范。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-| JerseyProperties</span><br><span class="line">-| JerseyAutoConfiguration</span><br><span class="line">-| ResourceConfigCustomizer</span><br></pre></td></tr></table></figure>
<h4 id="、jms-spring-jms-spring-artemis-spring-activemq"><a href="#、jms-spring-jms-spring-artemis-spring-activemq" class="headerlink" title="、jms - [spring.jms ; spring.artemis ; spring.activemq]"></a>、jms - [spring.jms ; spring.artemis ; spring.activemq]</h4><blockquote>
<p>JMS（JAVA Message Service,java消息服务）</p>
</blockquote>
<p><a href="http://www.iigrowing.cn/hornetq_yu_apache_artemis.html" target="_blank" rel="noopener">HornetQ与Apache Artemis</a></p>
<p><a href="http://jm.taobao.org/2017/03/09/20170309/" target="_blank" rel="noopener">Apache RocketMQ背后的设计思路与最佳实践</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">activemq:</span><br><span class="line">artemis:</span><br></pre></td></tr></table></figure>
<h4 id="、jmx-spring-jmx"><a href="#、jmx-spring-jmx" class="headerlink" title="、jmx - [spring.jmx]"></a>、jmx - [spring.jmx]</h4><blockquote>
<p><em>JMX</em>（Java Management Extensions，即Java管理扩展）是一个为应用程序、设备、系统等植入管理功能的框架。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-| JmxAutoConfiguration</span><br><span class="line">-| ParentAwareNamingStrategy</span><br></pre></td></tr></table></figure>
<h4 id="、jooq-spring-jooq"><a href="#、jooq-spring-jooq" class="headerlink" title="、jooq - [spring.jooq]"></a>、jooq - [spring.jooq]</h4><p><a href="https://segmentfault.com/a/1190000010415384" target="_blank" rel="noopener">JOOQ快速入门</a></p>
<p><a href="https://www.jianshu.com/p/46164f9ba53c" target="_blank" rel="noopener">ORM “杀器”之 JOOQ</a></p>
<p>和MybatisPlus区别？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-| JooqProperties</span><br><span class="line">-| JooqExceptionTranslator</span><br><span class="line">-| JooqAutoConfiguration</span><br><span class="line">-| SpringTransaction</span><br><span class="line">-| SpringTransactionProvider</span><br></pre></td></tr></table></figure>
<h4 id="、kafka-spring-kafka"><a href="#、kafka-spring-kafka" class="headerlink" title="、kafka - [spring.kafka]"></a>、kafka - [spring.kafka]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-| KafkaAutoConfiguration</span><br><span class="line">-| KafkaProperties</span><br><span class="line">-| KafkaAnnotationDrivenConfiguration</span><br><span class="line">-| ConcurrentKafkaListenerContainerFactoryConfigurer</span><br></pre></td></tr></table></figure>
<h4 id="、ldap-spring-ldap"><a href="#、ldap-spring-ldap" class="headerlink" title="、ldap - [spring.ldap]"></a>、ldap - [spring.ldap]</h4><p><em>LDAP</em>是轻量目录访问协议，英文全称是Lightweight Directory Access Protocol，一般都简称为<em>LDAP</em>。</p>
<p><a href="https://www.cnblogs.com/yjd_hycf_space/p/7994597.html" target="_blank" rel="noopener">LDAP服务器的概念和原理简单介绍</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">embedded - [spring.ldap.embedded]</span><br><span class="line">    -| EmbeddedLdapProperties</span><br><span class="line">    -| EmbeddedLdapAutoConfiguration</span><br><span class="line">-| LdapAutoConfiguration</span><br><span class="line">-| LdapProperties</span><br></pre></td></tr></table></figure>
<h4 id="、liquibase-liquibase"><a href="#、liquibase-liquibase" class="headerlink" title="、liquibase - [liquibase]"></a>、liquibase - [liquibase]</h4><p><em>LiquiBase</em>是一个用于数据库重构和迁移的开源工具,通过日志文件的形式记录数据库的变更,然后执行日志文件中的修改,将数据库更新或回滚到一致的状态。</p>
<p><a href="https://www.cnblogs.com/tonyq/p/8039770.html" target="_blank" rel="noopener">liquibase</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-| LiquibaseProperties</span><br><span class="line">-| LiquibaseAutoConfiguration</span><br></pre></td></tr></table></figure>
<h4 id="、logging"><a href="#、logging" class="headerlink" title="、logging"></a>、logging</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-| ConditionEvaluationReportMessage</span><br><span class="line">-| AutoConfigurationReportLoggingInitializer</span><br></pre></td></tr></table></figure>
<h4 id="、mail-spring-mail"><a href="#、mail-spring-mail" class="headerlink" title="、mail - [spring.mail]"></a>、mail - [spring.mail]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-| JndiSessionConfiguration</span><br><span class="line">-| MailProperties</span><br><span class="line">-| MailSenderAutoConfiguration</span><br><span class="line">-| MailSenderValidatorAutoConfiguration</span><br></pre></td></tr></table></figure>
<h4 id="、mobile-spring-mobile-devicedelegatingviewresolver-spring-mobile-sitepreference"><a href="#、mobile-spring-mobile-devicedelegatingviewresolver-spring-mobile-sitepreference" class="headerlink" title="、mobile - [spring.mobile.devicedelegatingviewresolver]/[spring.mobile.sitepreference]"></a>、mobile - [spring.mobile.devicedelegatingviewresolver]/[spring.mobile.sitepreference]</h4><p><em>spring</em> <em>mobile</em>框架是一个很小的,用于获取设备信息,然后跳转到不同视图的框架。</p>
<p><a href="https://github.com/spring-projects/spring-mobile" target="_blank" rel="noopener">spring-mobile开源地址</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-| spring.mobile.devicedelegatingviewresolver</span><br><span class="line">-| DeviceDelegatingViewResolverFactory</span><br><span class="line">-| DeviceDelegatingViewResolverAutoConfiguration</span><br><span class="line">-| DeviceResolverAutoConfiguration</span><br><span class="line">-| SitePreferenceAutoConfiguration</span><br></pre></td></tr></table></figure>
<h4 id="、mongo-spring-data-mongodb"><a href="#、mongo-spring-data-mongodb" class="headerlink" title="、mongo - [spring.data.mongodb]"></a>、mongo - [spring.data.mongodb]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">embedded: - [spring.mongodb.embedded]</span><br><span class="line">    -| EmbeddedMongoProperties</span><br><span class="line">    -| EmbeddedMongoAutoConfiguration</span><br><span class="line">-| MongoProperties</span><br><span class="line">-| MongoAutoConfiguration</span><br></pre></td></tr></table></figure>
<h4 id="、mustache-spring-mustache"><a href="#、mustache-spring-mustache" class="headerlink" title="、mustache - [spring.mustache]"></a>、mustache - [spring.mustache]</h4><p><a href="https://blog.csdn.net/wangwenjun69/article/details/45971563" target="_blank" rel="noopener">Mustache模板技术，一个比freemarker轻量级的模板引擎</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-| MustacheProperties extends AbstractTemplateViewResolverProperties</span><br><span class="line">-| MustacheAutoConfiguration</span><br><span class="line">-| MustacheCompilerFactoryBean</span><br><span class="line">-| MustacheEnvironmentCollector</span><br><span class="line">-| MustacheResourceTemplateLoader</span><br><span class="line">-| MustacheTemplateAvailabilityProvider</span><br></pre></td></tr></table></figure>
<h4 id="、orm-jpa-spring-jpa"><a href="#、orm-jpa-spring-jpa" class="headerlink" title="、orm.jpa - [spring.jpa]"></a>、orm.jpa - [spring.jpa]</h4><p><em>JPA</em>是Java Persistence API的简称，中文名Java持久层API，是JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。</p>
<p><a href="https://www.yiibai.com/jpa/jpa_orm_components.html" target="_blank" rel="noopener">JPA ORM组件</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-| JpaProperties</span><br><span class="line">-| JpaBaseConfiguration</span><br><span class="line">-| HibernateVersion</span><br><span class="line">-| HibernateJpaAutoConfiguration</span><br><span class="line">-| DataSourceInitializedPublisher</span><br><span class="line">-| DatabaseLookup</span><br></pre></td></tr></table></figure>
<h4 id="、reactor"><a href="#、reactor" class="headerlink" title="、reactor"></a>、reactor</h4><p><a href="https://github.com/reactor/reactor" target="_blank" rel="noopener">reactor-github</a></p>
<p><a href="http://spring.io/guides/gs/messaging-reactor/" target="_blank" rel="noopener">官方教程</a></p>
<p><a href="https://blog.csdn.net/shida_csdn/article/details/78194965?locationNum=10&amp;fps=1" target="_blank" rel="noopener">SpringBoot 集成 Reactor 事件处理框架</a></p>
<p>  Reactor 是 Spring 社区发布的基于事件驱动的异步框架，不仅解耦了程序之间的强调用关系，而且有效提升了系统的多线程并发处理能力。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-| ReactorAutoConfiguration</span><br></pre></td></tr></table></figure>
<h4 id="、security-security"><a href="#、security-security" class="headerlink" title="、security - [security]"></a>、security - [security]</h4><p><a href="https://blog.csdn.net/dalangzhonghangxing/article/details/53024640" target="_blank" rel="noopener">spring security入门</a></p>
<p>Spring Security是能够为J2EE项目提供综合性的安全访问控制解决方案的安全框架。它依赖于Servlet过滤器。这些过滤器拦截进入请求，并且在应用程序处理该请求之前进行某些安全处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oauth2 - [security.oauth2.client]</span><br></pre></td></tr></table></figure>
<h4 id="、sendgrid-spring-sendgrid"><a href="#、sendgrid-spring-sendgrid" class="headerlink" title="、sendgrid - [spring.sendgrid]"></a>、sendgrid - [spring.sendgrid]</h4><p> <em>SendGrid</em> 是一个电子邮件服务平台,可以帮助市场营销人员跟踪他们的电子邮件统计数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-| SendGridProperties</span><br><span class="line">-| SendGridAutoConfiguration</span><br></pre></td></tr></table></figure>
<h4 id="、session-spring-session"><a href="#、session-spring-session" class="headerlink" title="、session - [spring.session]"></a>、session - [spring.session]</h4><p><a href="https://blog.csdn.net/wojiaolinaaa/article/details/62424642" target="_blank" rel="noopener">spring-session简介、使用及实现原理</a></p>
<p><a href="http://docs.spring.io/spring-session/docs/1.3.0.RELEASE/reference/html5/" target="_blank" rel="noopener">官网的samples and guide </a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-| SessionProperties</span><br></pre></td></tr></table></figure>
<h4 id="、social-spring-social-facebook-spring-social-linkedin-spring-social-twitter"><a href="#、social-spring-social-facebook-spring-social-linkedin-spring-social-twitter" class="headerlink" title="、social - [spring.social.facebook]/[spring.social.linkedin]/[spring.social.twitter]"></a>、social - [spring.social.facebook]/[spring.social.linkedin]/[spring.social.twitter]</h4><p><a href="https://blog.csdn.net/dandandeshangni/article/details/79042704" target="_blank" rel="noopener">Spring Social实现微信社交登录</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-| SocialAutoConfigurerAdapter</span><br><span class="line">-| SocialProperties</span><br><span class="line">-| SocialWebAutoConfiguration</span><br></pre></td></tr></table></figure>
<h4 id="、solr-spring-data-solr"><a href="#、solr-spring-data-solr" class="headerlink" title="、solr - [spring.data.solr]"></a>、solr - [spring.data.solr]</h4><p>Solr是一个高性能，采用Java5开发，基于Lucene的全文搜索服务器。</p>
<p><a href="https://blog.csdn.net/frankcheng5143/article/details/71159936" target="_blank" rel="noopener">项目中如何使用solr</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-| SolrProperties</span><br><span class="line">-| SolrAutoConfiguration</span><br></pre></td></tr></table></figure>
<h4 id="、template"><a href="#、template" class="headerlink" title="、template - []"></a>、template - []</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-| AbstractViewResolverProperties</span><br><span class="line">-| AbstractTemplateViewResolverProperties</span><br><span class="line">    -| 实现：FreeMarkerProperties、GroovyTemplateProperties、MustacheProperties</span><br><span class="line">-| TemplateAvailabilityProvider</span><br><span class="line">-| TemplateAvailabilityProviders</span><br><span class="line">-| TemplateLocation</span><br></pre></td></tr></table></figure>
<h4 id="、thymeleaf-spring-thymeleaf"><a href="#、thymeleaf-spring-thymeleaf" class="headerlink" title="、thymeleaf - [spring.thymeleaf]"></a>、thymeleaf - [spring.thymeleaf]</h4><p><em>Thymeleaf</em> 是一个跟 Velocity、<em>FreeMarker</em> 类似的模板引擎。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-| ThymeleafProperties</span><br><span class="line">-| ThymeleafAutoConfiguration</span><br><span class="line">-| AbstractThymeleafViewResolverConfiguration</span><br><span class="line">-| AbstractTemplateResolverConfiguration</span><br><span class="line">-| ThymeleafTemplateAvailabilityProvider</span><br></pre></td></tr></table></figure>
<h4 id="、transaction-spring-transaction"><a href="#、transaction-spring-transaction" class="headerlink" title="、transaction - [spring.transaction]"></a>、transaction - [spring.transaction]</h4><p>JTA，即Java Transaction API，JTA允许应用程序执行分布式事务处理——在两个或多个网络计算机资源上访问并且更新数据。<a href="https://baike.baidu.com/item/JDBC" target="_blank" rel="noopener">JDBC</a><a href="https://baike.baidu.com/item/%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F" target="_blank" rel="noopener">驱动程序</a>的JTA支持极大地增强了数据访问能力。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jta - [spring.jta]</span><br><span class="line">    -| AtomikosJtaConfiguration</span><br><span class="line">    -| BitronixJtaConfiguration</span><br><span class="line">    -| JndiJtaConfiguration</span><br><span class="line">    -| JtaAutoConfiguration</span><br><span class="line">    -| JtaProperties</span><br><span class="line">    -| NarayanaJtaConfiguration</span><br><span class="line">-| PlatformTransactionManagerCustomizer</span><br><span class="line">-| TransactionAutoConfiguration</span><br><span class="line">-| TransactionManagerCustomizers</span><br><span class="line">-| TransactionProperties</span><br></pre></td></tr></table></figure>
<h4 id="、validation"><a href="#、validation" class="headerlink" title="、validation"></a>、validation</h4><p>@ConditionalOnResource(resources = “classpath:META-INF/services/javax.validation.spi.ValidationProvider”)</p>
<p><a href="https://blog.csdn.net/u013815546/article/details/77248003" target="_blank" rel="noopener">使用spring validation完成数据后端校验</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-| ValidationAutoConfiguration</span><br></pre></td></tr></table></figure>
<h4 id="、web"><a href="#、web" class="headerlink" title="、web"></a>、web</h4><p>web相关</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;error.path:/error&#125;&quot;)</span><br><span class="line">private String path = &quot;/error&quot;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpEncodingProperties ： [spring.http.encoding]</span><br><span class="line">MultipartProperties ： [spring.http.multipart]</span><br><span class="line">ResourceProperties ： [spring.resources]</span><br><span class="line">ServerProperties ： [server]</span><br><span class="line">WebMvcProperties ： [spring.mvc]</span><br></pre></td></tr></table></figure>
<h4 id="、webservices-spring-webservices"><a href="#、webservices-spring-webservices" class="headerlink" title="、webservices - [spring.webservices]"></a>、webservices - [spring.webservices]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-| WebServicesAutoConfiguration</span><br><span class="line">-| WebServicesProperties</span><br></pre></td></tr></table></figure>
<h4 id="、websocket"><a href="#、websocket" class="headerlink" title="、websocket - []"></a>、websocket - []</h4><p><a href="https://blog.csdn.net/derrantcm/article/details/77547337" target="_blank" rel="noopener">SpringBoot——核心-WebSocket</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-| JettyWebSocketContainerCustomizer</span><br><span class="line">-| TomcatWebSocketContainerCustomizer</span><br><span class="line">-| UndertowWebSocketContainerCustomizer</span><br><span class="line">-| WebSocketAutoConfiguration</span><br><span class="line">-| WebSocketContainerCustomizer</span><br><span class="line">-| WebSocketMessagingAutoConfiguration</span><br></pre></td></tr></table></figure>
<h4 id="———-others"><a href="#———-others" class="headerlink" title="——— others"></a>——— others</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-| AbstractDatabaseInitializer</span><br><span class="line">-| AbstractDependsOnBeanFactoryPostProcessor</span><br><span class="line">-| AutoConfigurationExcludeFilter</span><br><span class="line">-| AutoConfigurationImportEvent</span><br><span class="line">-| AutoConfigurationImportFilter</span><br><span class="line">-| AutoConfigurationImportListener</span><br><span class="line">-| AutoConfigurationImportSelector</span><br><span class="line">-| AutoConfigurationMetadata</span><br><span class="line">-| AutoConfigurationMetadataLoader</span><br><span class="line">-| AutoConfigurationPackages</span><br><span class="line">-| AutoConfigurationSorter</span><br><span class="line">-| BackgroundPreinitializer</span><br><span class="line">-| ImportAutoConfigurationImportSelector</span><br></pre></td></tr></table></figure>
<p>#####析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JMX（Java Management Extensions，即Java管理扩展</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yanxisir.com/2018/04/10/心中田间-木行水上/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yanxi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YanxiSir">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/10/心中田间-木行水上/" itemprop="url">心中田间,木行水上</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-10T20:58:55+08:00">
                2018-04-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>​    好多年没写东西了，上次还得追溯到高考语文作文那个时候。后来的自己一直太懒，没有思考，没有沉淀。现在好不容易动手起来，想借此机会记录下自己在学习过程中的一些东西，就当做个backup吧。也不至于到时候回头看的时候什么积淀都没有。</p>
<p>​    心中田间，木行水上。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Yanxi" />
          <p class="site-author-name" itemprop="name">Yanxi</p>
           
              <p class="site-description motion-element" itemprop="description">Yanxi's zone</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yanxi</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
